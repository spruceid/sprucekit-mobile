// Autogenerated from Pigeon (v26.1.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package com.spruceid.sprucekit_mobile

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
private object CredentialPackPigeonUtils {

  fun wrapResult(result: Any?): List<Any?> {
    return listOf(result)
  }

  fun wrapError(exception: Throwable): List<Any?> {
    return if (exception is CredentialPackFlutterError) {
      listOf(
        exception.code,
        exception.message,
        exception.details
      )
    } else {
      listOf(
        exception.javaClass.simpleName,
        exception.toString(),
        "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
      )
    }
  }
  fun deepEquals(a: Any?, b: Any?): Boolean {
    if (a is ByteArray && b is ByteArray) {
        return a.contentEquals(b)
    }
    if (a is IntArray && b is IntArray) {
        return a.contentEquals(b)
    }
    if (a is LongArray && b is LongArray) {
        return a.contentEquals(b)
    }
    if (a is DoubleArray && b is DoubleArray) {
        return a.contentEquals(b)
    }
    if (a is Array<*> && b is Array<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is List<*> && b is List<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is Map<*, *> && b is Map<*, *>) {
      return a.size == b.size && a.all {
          (b as Map<Any?, Any?>).contains(it.key) &&
          deepEquals(it.value, b[it.key])
      }
    }
    return a == b
  }
      
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class CredentialPackFlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Credential status from status list */
enum class CredentialStatus(val raw: Int) {
  VALID(0),
  REVOKED(1),
  SUSPENDED(2),
  UNKNOWN(3),
  INVALID(4),
  UNDEFINED(5),
  PENDING(6),
  READY(7);

  companion object {
    fun ofRaw(raw: Int): CredentialStatus? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Credential format type */
enum class CredentialFormat(val raw: Int) {
  JWT_VC(0),
  JSON_VC(1),
  SD_JWT(2),
  MSO_MDOC(3),
  CWT(4);

  companion object {
    fun ofRaw(raw: Int): CredentialFormat? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * A parsed credential with its metadata
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ParsedCredentialData (
  /** Unique identifier for this credential */
  val id: String,
  /** The credential format */
  val format: CredentialFormat,
  /** Raw credential data as string */
  val rawCredential: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ParsedCredentialData {
      val id = pigeonVar_list[0] as String
      val format = pigeonVar_list[1] as CredentialFormat
      val rawCredential = pigeonVar_list[2] as String
      return ParsedCredentialData(id, format, rawCredential)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      format,
      rawCredential,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is ParsedCredentialData) {
      return false
    }
    if (this === other) {
      return true
    }
    return CredentialPackPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * A credential pack with its credentials
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CredentialPackData (
  /** Unique identifier for this pack */
  val id: String,
  /** List of credentials in this pack */
  val credentials: List<ParsedCredentialData>
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CredentialPackData {
      val id = pigeonVar_list[0] as String
      val credentials = pigeonVar_list[1] as List<ParsedCredentialData>
      return CredentialPackData(id, credentials)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      credentials,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is CredentialPackData) {
      return false
    }
    if (this === other) {
      return true
    }
    return CredentialPackPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Result types for credential operations
 *
 * Generated class from Pigeon that represents data sent in messages.
 * This class should not be extended by any user class outside of the generated file.
 */
sealed class CredentialOperationResult 
/**
 * Operation succeeded
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CredentialOperationSuccess (
  val unused: Long? = null
) : CredentialOperationResult()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CredentialOperationSuccess {
      val unused = pigeonVar_list[0] as Long?
      return CredentialOperationSuccess(unused)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      unused,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is CredentialOperationSuccess) {
      return false
    }
    if (this === other) {
      return true
    }
    return CredentialPackPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Operation failed with error message
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CredentialOperationError (
  val message: String
) : CredentialOperationResult()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CredentialOperationError {
      val message = pigeonVar_list[0] as String
      return CredentialOperationError(message)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      message,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is CredentialOperationError) {
      return false
    }
    if (this === other) {
      return true
    }
    return CredentialPackPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Result of adding a credential
 *
 * Generated class from Pigeon that represents data sent in messages.
 * This class should not be extended by any user class outside of the generated file.
 */
sealed class AddCredentialResult 
/**
 * Adding credential succeeded
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class AddCredentialSuccess (
  /** The updated list of credentials in the pack */
  val credentials: List<ParsedCredentialData>
) : AddCredentialResult()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): AddCredentialSuccess {
      val credentials = pigeonVar_list[0] as List<ParsedCredentialData>
      return AddCredentialSuccess(credentials)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      credentials,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is AddCredentialSuccess) {
      return false
    }
    if (this === other) {
      return true
    }
    return CredentialPackPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Adding credential failed
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class AddCredentialError (
  val message: String
) : AddCredentialResult()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): AddCredentialError {
      val message = pigeonVar_list[0] as String
      return AddCredentialError(message)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      message,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is AddCredentialError) {
      return false
    }
    if (this === other) {
      return true
    }
    return CredentialPackPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}
private open class CredentialPackPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          CredentialStatus.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          CredentialFormat.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ParsedCredentialData.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CredentialPackData.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CredentialOperationSuccess.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CredentialOperationError.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AddCredentialSuccess.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AddCredentialError.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is CredentialStatus -> {
        stream.write(129)
        writeValue(stream, value.raw.toLong())
      }
      is CredentialFormat -> {
        stream.write(130)
        writeValue(stream, value.raw.toLong())
      }
      is ParsedCredentialData -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is CredentialPackData -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is CredentialOperationSuccess -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is CredentialOperationError -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is AddCredentialSuccess -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is AddCredentialError -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}


/**
 * CredentialPack management API
 *
 * Manages collections of credentials with parsing and storage capabilities
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface CredentialPack {
  /**
   * Create a new empty credential pack
   *
   * @return The pack ID
   */
  fun createPack(): String
  /**
   * Get a credential pack by ID
   *
   * @param packId The pack identifier
   * @return The credential pack data, or null if not found
   */
  fun getPack(packId: String): CredentialPackData?
  /**
   * Add a raw credential to a pack (auto-detects format)
   *
   * Tries to parse the credential as: JWT VC, JSON VC, SD-JWT, or CWT
   *
   * @param packId The pack identifier
   * @param rawCredential The raw credential string
   * @return AddCredentialResult with updated credentials or error
   */
  fun addRawCredential(packId: String, rawCredential: String, callback: (Result<AddCredentialResult>) -> Unit)
  /**
   * Add a raw mDoc credential to a pack
   *
   * @param packId The pack identifier
   * @param rawCredential The raw mDoc credential
   * @param keyAlias The key alias to use for the mDoc
   * @return AddCredentialResult with updated credentials or error
   */
  fun addRawMdoc(packId: String, rawCredential: String, keyAlias: String, callback: (Result<AddCredentialResult>) -> Unit)
  /**
   * Add a credential in any supported format
   *
   * Tries standard formats first, then mDoc with the provided key alias
   *
   * @param packId The pack identifier
   * @param rawCredential The raw credential string
   * @param mdocKeyAlias The key alias to use if parsing as mDoc
   * @return AddCredentialResult with updated credentials or error
   */
  fun addAnyFormat(packId: String, rawCredential: String, mdocKeyAlias: String, callback: (Result<AddCredentialResult>) -> Unit)
  /**
   * Get all credentials in a pack
   *
   * @param packId The pack identifier
   * @return List of credentials, empty if pack not found
   */
  fun listCredentials(packId: String): List<ParsedCredentialData>
  /**
   * Get credential claims
   *
   * @param packId The pack identifier
   * @param credentialId The credential identifier
   * @param claimNames Optional list of claim names to filter (empty = all claims)
   * @return JSON string of claims, or null if not found
   */
  fun getCredentialClaims(packId: String, credentialId: String, claimNames: List<String>): String?
  /**
   * Delete a credential pack
   *
   * @param packId The pack identifier
   * @param appGroupId Optional App Group ID (iOS) for persistent storage
   * @return CredentialOperationResult indicating success or error
   */
  fun deletePack(packId: String, appGroupId: String?, callback: (Result<CredentialOperationResult>) -> Unit)
  /**
   * Get all credential pack IDs
   *
   * @return List of pack IDs (in-memory only)
   */
  fun listPacks(): List<String>
  /**
   * Save a credential pack to persistent storage
   *
   * On iOS: Uses StorageManager with App Group for shared storage
   * On Android: Uses StorageManager with app-private storage
   *
   * @param packId The pack identifier
   * @param appGroupId Optional App Group ID (iOS only) for shared storage with extensions
   * @return CredentialOperationResult indicating success or error
   */
  fun savePack(packId: String, appGroupId: String?, callback: (Result<CredentialOperationResult>) -> Unit)
  /**
   * Load all credential packs from persistent storage
   *
   * On iOS: Uses StorageManager with App Group for shared storage
   * On Android: Uses StorageManager with app-private storage
   *
   * @param appGroupId Optional App Group ID (iOS only) for shared storage with extensions
   * @return List of loaded pack IDs
   */
  fun loadAllPacks(appGroupId: String?, callback: (Result<List<String>>) -> Unit)

  companion object {
    /** The codec used by CredentialPack. */
    val codec: MessageCodec<Any?> by lazy {
      CredentialPackPigeonCodec()
    }
    /** Sets up an instance of `CredentialPack` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: CredentialPack?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.createPack$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.createPack())
            } catch (exception: Throwable) {
              CredentialPackPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.getPack$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val packIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.getPack(packIdArg))
            } catch (exception: Throwable) {
              CredentialPackPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.addRawCredential$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val packIdArg = args[0] as String
            val rawCredentialArg = args[1] as String
            api.addRawCredential(packIdArg, rawCredentialArg) { result: Result<AddCredentialResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(CredentialPackPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(CredentialPackPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.addRawMdoc$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val packIdArg = args[0] as String
            val rawCredentialArg = args[1] as String
            val keyAliasArg = args[2] as String
            api.addRawMdoc(packIdArg, rawCredentialArg, keyAliasArg) { result: Result<AddCredentialResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(CredentialPackPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(CredentialPackPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.addAnyFormat$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val packIdArg = args[0] as String
            val rawCredentialArg = args[1] as String
            val mdocKeyAliasArg = args[2] as String
            api.addAnyFormat(packIdArg, rawCredentialArg, mdocKeyAliasArg) { result: Result<AddCredentialResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(CredentialPackPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(CredentialPackPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.listCredentials$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val packIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.listCredentials(packIdArg))
            } catch (exception: Throwable) {
              CredentialPackPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.getCredentialClaims$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val packIdArg = args[0] as String
            val credentialIdArg = args[1] as String
            val claimNamesArg = args[2] as List<String>
            val wrapped: List<Any?> = try {
              listOf(api.getCredentialClaims(packIdArg, credentialIdArg, claimNamesArg))
            } catch (exception: Throwable) {
              CredentialPackPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.deletePack$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val packIdArg = args[0] as String
            val appGroupIdArg = args[1] as String?
            api.deletePack(packIdArg, appGroupIdArg) { result: Result<CredentialOperationResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(CredentialPackPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(CredentialPackPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.listPacks$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.listPacks())
            } catch (exception: Throwable) {
              CredentialPackPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.savePack$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val packIdArg = args[0] as String
            val appGroupIdArg = args[1] as String?
            api.savePack(packIdArg, appGroupIdArg) { result: Result<CredentialOperationResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(CredentialPackPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(CredentialPackPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.loadAllPacks$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val appGroupIdArg = args[0] as String?
            api.loadAllPacks(appGroupIdArg) { result: Result<List<String>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(CredentialPackPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(CredentialPackPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
