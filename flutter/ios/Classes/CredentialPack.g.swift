// Autogenerated from Pigeon (v26.1.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class CredentialPackPigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "CredentialPackPigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? CredentialPackPigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

func deepEqualsCredentialPack(_ lhs: Any?, _ rhs: Any?) -> Bool {
  let cleanLhs = nilOrValue(lhs) as Any?
  let cleanRhs = nilOrValue(rhs) as Any?
  switch (cleanLhs, cleanRhs) {
  case (nil, nil):
    return true

  case (nil, _), (_, nil):
    return false

  case is (Void, Void):
    return true

  case let (cleanLhsHashable, cleanRhsHashable) as (AnyHashable, AnyHashable):
    return cleanLhsHashable == cleanRhsHashable

  case let (cleanLhsArray, cleanRhsArray) as ([Any?], [Any?]):
    guard cleanLhsArray.count == cleanRhsArray.count else { return false }
    for (index, element) in cleanLhsArray.enumerated() {
      if !deepEqualsCredentialPack(element, cleanRhsArray[index]) {
        return false
      }
    }
    return true

  case let (cleanLhsDictionary, cleanRhsDictionary) as ([AnyHashable: Any?], [AnyHashable: Any?]):
    guard cleanLhsDictionary.count == cleanRhsDictionary.count else { return false }
    for (key, cleanLhsValue) in cleanLhsDictionary {
      guard cleanRhsDictionary.index(forKey: key) != nil else { return false }
      if !deepEqualsCredentialPack(cleanLhsValue, cleanRhsDictionary[key]!) {
        return false
      }
    }
    return true

  default:
    // Any other type shouldn't be able to be used with pigeon. File an issue if you find this to be untrue.
    return false
  }
}

func deepHashCredentialPack(value: Any?, hasher: inout Hasher) {
  if let valueList = value as? [AnyHashable] {
     for item in valueList { deepHashCredentialPack(value: item, hasher: &hasher) }
     return
  }

  if let valueDict = value as? [AnyHashable: AnyHashable] {
    for key in valueDict.keys { 
      hasher.combine(key)
      deepHashCredentialPack(value: valueDict[key]!, hasher: &hasher)
    }
    return
  }

  if let hashableValue = value as? AnyHashable {
    hasher.combine(hashableValue.hashValue)
  }

  return hasher.combine(String(describing: value))
}

    

/// Credential status from status list
enum CredentialStatus: Int {
  case valid = 0
  case revoked = 1
  case suspended = 2
  case unknown = 3
  case invalid = 4
  case undefined = 5
  case pending = 6
  case ready = 7
}

/// Credential format type
enum CredentialFormat: Int {
  case jwtVc = 0
  case jsonVc = 1
  case sdJwt = 2
  case msoMdoc = 3
  case cwt = 4
}

/// A parsed credential with its metadata
///
/// Generated class from Pigeon that represents data sent in messages.
struct ParsedCredentialData: Hashable {
  /// Unique identifier for this credential
  var id: String
  /// The credential format
  var format: CredentialFormat
  /// Raw credential data as string
  var rawCredential: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ParsedCredentialData? {
    let id = pigeonVar_list[0] as! String
    let format = pigeonVar_list[1] as! CredentialFormat
    let rawCredential = pigeonVar_list[2] as! String

    return ParsedCredentialData(
      id: id,
      format: format,
      rawCredential: rawCredential
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      format,
      rawCredential,
    ]
  }
  static func == (lhs: ParsedCredentialData, rhs: ParsedCredentialData) -> Bool {
    return deepEqualsCredentialPack(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashCredentialPack(value: toList(), hasher: &hasher)
  }
}

/// A credential pack with its credentials
///
/// Generated class from Pigeon that represents data sent in messages.
struct CredentialPackData: Hashable {
  /// Unique identifier for this pack
  var id: String
  /// List of credentials in this pack
  var credentials: [ParsedCredentialData]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CredentialPackData? {
    let id = pigeonVar_list[0] as! String
    let credentials = pigeonVar_list[1] as! [ParsedCredentialData]

    return CredentialPackData(
      id: id,
      credentials: credentials
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      credentials,
    ]
  }
  static func == (lhs: CredentialPackData, rhs: CredentialPackData) -> Bool {
    return deepEqualsCredentialPack(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashCredentialPack(value: toList(), hasher: &hasher)
  }
}

/// Result types for credential operations
///
/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol CredentialOperationResult {

}

/// Operation succeeded
///
/// Generated class from Pigeon that represents data sent in messages.
struct CredentialOperationSuccess: CredentialOperationResult {
  var unused: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CredentialOperationSuccess? {
    let unused: Int64? = nilOrValue(pigeonVar_list[0])

    return CredentialOperationSuccess(
      unused: unused
    )
  }
  func toList() -> [Any?] {
    return [
      unused
    ]
  }
  static func == (lhs: CredentialOperationSuccess, rhs: CredentialOperationSuccess) -> Bool {
    return deepEqualsCredentialPack(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashCredentialPack(value: toList(), hasher: &hasher)
  }
}

/// Operation failed with error message
///
/// Generated class from Pigeon that represents data sent in messages.
struct CredentialOperationError: CredentialOperationResult {
  var message: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CredentialOperationError? {
    let message = pigeonVar_list[0] as! String

    return CredentialOperationError(
      message: message
    )
  }
  func toList() -> [Any?] {
    return [
      message
    ]
  }
  static func == (lhs: CredentialOperationError, rhs: CredentialOperationError) -> Bool {
    return deepEqualsCredentialPack(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashCredentialPack(value: toList(), hasher: &hasher)
  }
}

/// Result of adding a credential
///
/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol AddCredentialResult {

}

/// Adding credential succeeded
///
/// Generated class from Pigeon that represents data sent in messages.
struct AddCredentialSuccess: AddCredentialResult {
  /// The updated list of credentials in the pack
  var credentials: [ParsedCredentialData]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> AddCredentialSuccess? {
    let credentials = pigeonVar_list[0] as! [ParsedCredentialData]

    return AddCredentialSuccess(
      credentials: credentials
    )
  }
  func toList() -> [Any?] {
    return [
      credentials
    ]
  }
  static func == (lhs: AddCredentialSuccess, rhs: AddCredentialSuccess) -> Bool {
    return deepEqualsCredentialPack(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashCredentialPack(value: toList(), hasher: &hasher)
  }
}

/// Adding credential failed
///
/// Generated class from Pigeon that represents data sent in messages.
struct AddCredentialError: AddCredentialResult {
  var message: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> AddCredentialError? {
    let message = pigeonVar_list[0] as! String

    return AddCredentialError(
      message: message
    )
  }
  func toList() -> [Any?] {
    return [
      message
    ]
  }
  static func == (lhs: AddCredentialError, rhs: AddCredentialError) -> Bool {
    return deepEqualsCredentialPack(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashCredentialPack(value: toList(), hasher: &hasher)
  }
}

private class CredentialPackPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CredentialStatus(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CredentialFormat(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      return ParsedCredentialData.fromList(self.readValue() as! [Any?])
    case 132:
      return CredentialPackData.fromList(self.readValue() as! [Any?])
    case 133:
      return CredentialOperationSuccess.fromList(self.readValue() as! [Any?])
    case 134:
      return CredentialOperationError.fromList(self.readValue() as! [Any?])
    case 135:
      return AddCredentialSuccess.fromList(self.readValue() as! [Any?])
    case 136:
      return AddCredentialError.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class CredentialPackPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CredentialStatus {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? CredentialFormat {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? ParsedCredentialData {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? CredentialPackData {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? CredentialOperationSuccess {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? CredentialOperationError {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? AddCredentialSuccess {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? AddCredentialError {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class CredentialPackPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return CredentialPackPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CredentialPackPigeonCodecWriter(data: data)
  }
}

class CredentialPackPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = CredentialPackPigeonCodec(readerWriter: CredentialPackPigeonCodecReaderWriter())
}


/// CredentialPack management API
///
/// Manages collections of credentials with parsing and storage capabilities
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol CredentialPack {
  /// Create a new empty credential pack
  ///
  /// @return The pack ID
  func createPack() throws -> String
  /// Get a credential pack by ID
  ///
  /// @param packId The pack identifier
  /// @return The credential pack data, or null if not found
  func getPack(packId: String) throws -> CredentialPackData?
  /// Add a raw credential to a pack (auto-detects format)
  ///
  /// Tries to parse the credential as: JWT VC, JSON VC, SD-JWT, or CWT
  ///
  /// @param packId The pack identifier
  /// @param rawCredential The raw credential string
  /// @return AddCredentialResult with updated credentials or error
  func addRawCredential(packId: String, rawCredential: String, completion: @escaping (Result<AddCredentialResult, Error>) -> Void)
  /// Add a raw mDoc credential to a pack
  ///
  /// @param packId The pack identifier
  /// @param rawCredential The raw mDoc credential
  /// @param keyAlias The key alias to use for the mDoc
  /// @return AddCredentialResult with updated credentials or error
  func addRawMdoc(packId: String, rawCredential: String, keyAlias: String, completion: @escaping (Result<AddCredentialResult, Error>) -> Void)
  /// Add a credential in any supported format
  ///
  /// Tries standard formats first, then mDoc with the provided key alias
  ///
  /// @param packId The pack identifier
  /// @param rawCredential The raw credential string
  /// @param mdocKeyAlias The key alias to use if parsing as mDoc
  /// @return AddCredentialResult with updated credentials or error
  func addAnyFormat(packId: String, rawCredential: String, mdocKeyAlias: String, completion: @escaping (Result<AddCredentialResult, Error>) -> Void)
  /// Get all credentials in a pack
  ///
  /// @param packId The pack identifier
  /// @return List of credentials, empty if pack not found
  func listCredentials(packId: String) throws -> [ParsedCredentialData]
  /// Get credential claims
  ///
  /// @param packId The pack identifier
  /// @param credentialId The credential identifier
  /// @param claimNames Optional list of claim names to filter (empty = all claims)
  /// @return JSON string of claims, or null if not found
  func getCredentialClaims(packId: String, credentialId: String, claimNames: [String]) throws -> String?
  /// Delete a credential pack
  ///
  /// @param packId The pack identifier
  /// @param appGroupId Optional App Group ID (iOS) for persistent storage
  /// @return CredentialOperationResult indicating success or error
  func deletePack(packId: String, appGroupId: String?, completion: @escaping (Result<CredentialOperationResult, Error>) -> Void)
  /// Get all credential pack IDs
  ///
  /// @return List of pack IDs (in-memory only)
  func listPacks() throws -> [String]
  /// Save a credential pack to persistent storage
  ///
  /// On iOS: Uses StorageManager with App Group for shared storage
  /// On Android: Uses StorageManager with app-private storage
  ///
  /// @param packId The pack identifier
  /// @param appGroupId Optional App Group ID (iOS only) for shared storage with extensions
  /// @return CredentialOperationResult indicating success or error
  func savePack(packId: String, appGroupId: String?, completion: @escaping (Result<CredentialOperationResult, Error>) -> Void)
  /// Load all credential packs from persistent storage
  ///
  /// On iOS: Uses StorageManager with App Group for shared storage
  /// On Android: Uses StorageManager with app-private storage
  ///
  /// @param appGroupId Optional App Group ID (iOS only) for shared storage with extensions
  /// @return List of loaded pack IDs
  func loadAllPacks(appGroupId: String?, completion: @escaping (Result<[String], Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class CredentialPackSetup {
  static var codec: FlutterStandardMessageCodec { CredentialPackPigeonCodec.shared }
  /// Sets up an instance of `CredentialPack` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: CredentialPack?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Create a new empty credential pack
    ///
    /// @return The pack ID
    let createPackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.createPack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createPackChannel.setMessageHandler { _, reply in
        do {
          let result = try api.createPack()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createPackChannel.setMessageHandler(nil)
    }
    /// Get a credential pack by ID
    ///
    /// @param packId The pack identifier
    /// @return The credential pack data, or null if not found
    let getPackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.getPack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let packIdArg = args[0] as! String
        do {
          let result = try api.getPack(packId: packIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPackChannel.setMessageHandler(nil)
    }
    /// Add a raw credential to a pack (auto-detects format)
    ///
    /// Tries to parse the credential as: JWT VC, JSON VC, SD-JWT, or CWT
    ///
    /// @param packId The pack identifier
    /// @param rawCredential The raw credential string
    /// @return AddCredentialResult with updated credentials or error
    let addRawCredentialChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.addRawCredential\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addRawCredentialChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let packIdArg = args[0] as! String
        let rawCredentialArg = args[1] as! String
        api.addRawCredential(packId: packIdArg, rawCredential: rawCredentialArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addRawCredentialChannel.setMessageHandler(nil)
    }
    /// Add a raw mDoc credential to a pack
    ///
    /// @param packId The pack identifier
    /// @param rawCredential The raw mDoc credential
    /// @param keyAlias The key alias to use for the mDoc
    /// @return AddCredentialResult with updated credentials or error
    let addRawMdocChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.addRawMdoc\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addRawMdocChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let packIdArg = args[0] as! String
        let rawCredentialArg = args[1] as! String
        let keyAliasArg = args[2] as! String
        api.addRawMdoc(packId: packIdArg, rawCredential: rawCredentialArg, keyAlias: keyAliasArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addRawMdocChannel.setMessageHandler(nil)
    }
    /// Add a credential in any supported format
    ///
    /// Tries standard formats first, then mDoc with the provided key alias
    ///
    /// @param packId The pack identifier
    /// @param rawCredential The raw credential string
    /// @param mdocKeyAlias The key alias to use if parsing as mDoc
    /// @return AddCredentialResult with updated credentials or error
    let addAnyFormatChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.addAnyFormat\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addAnyFormatChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let packIdArg = args[0] as! String
        let rawCredentialArg = args[1] as! String
        let mdocKeyAliasArg = args[2] as! String
        api.addAnyFormat(packId: packIdArg, rawCredential: rawCredentialArg, mdocKeyAlias: mdocKeyAliasArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addAnyFormatChannel.setMessageHandler(nil)
    }
    /// Get all credentials in a pack
    ///
    /// @param packId The pack identifier
    /// @return List of credentials, empty if pack not found
    let listCredentialsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.listCredentials\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      listCredentialsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let packIdArg = args[0] as! String
        do {
          let result = try api.listCredentials(packId: packIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      listCredentialsChannel.setMessageHandler(nil)
    }
    /// Get credential claims
    ///
    /// @param packId The pack identifier
    /// @param credentialId The credential identifier
    /// @param claimNames Optional list of claim names to filter (empty = all claims)
    /// @return JSON string of claims, or null if not found
    let getCredentialClaimsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.getCredentialClaims\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCredentialClaimsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let packIdArg = args[0] as! String
        let credentialIdArg = args[1] as! String
        let claimNamesArg = args[2] as! [String]
        do {
          let result = try api.getCredentialClaims(packId: packIdArg, credentialId: credentialIdArg, claimNames: claimNamesArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCredentialClaimsChannel.setMessageHandler(nil)
    }
    /// Delete a credential pack
    ///
    /// @param packId The pack identifier
    /// @param appGroupId Optional App Group ID (iOS) for persistent storage
    /// @return CredentialOperationResult indicating success or error
    let deletePackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.deletePack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deletePackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let packIdArg = args[0] as! String
        let appGroupIdArg: String? = nilOrValue(args[1])
        api.deletePack(packId: packIdArg, appGroupId: appGroupIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deletePackChannel.setMessageHandler(nil)
    }
    /// Get all credential pack IDs
    ///
    /// @return List of pack IDs (in-memory only)
    let listPacksChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.listPacks\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      listPacksChannel.setMessageHandler { _, reply in
        do {
          let result = try api.listPacks()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      listPacksChannel.setMessageHandler(nil)
    }
    /// Save a credential pack to persistent storage
    ///
    /// On iOS: Uses StorageManager with App Group for shared storage
    /// On Android: Uses StorageManager with app-private storage
    ///
    /// @param packId The pack identifier
    /// @param appGroupId Optional App Group ID (iOS only) for shared storage with extensions
    /// @return CredentialOperationResult indicating success or error
    let savePackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.savePack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      savePackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let packIdArg = args[0] as! String
        let appGroupIdArg: String? = nilOrValue(args[1])
        api.savePack(packId: packIdArg, appGroupId: appGroupIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      savePackChannel.setMessageHandler(nil)
    }
    /// Load all credential packs from persistent storage
    ///
    /// On iOS: Uses StorageManager with App Group for shared storage
    /// On Android: Uses StorageManager with app-private storage
    ///
    /// @param appGroupId Optional App Group ID (iOS only) for shared storage with extensions
    /// @return List of loaded pack IDs
    let loadAllPacksChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.CredentialPack.loadAllPacks\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadAllPacksChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appGroupIdArg: String? = nilOrValue(args[0])
        api.loadAllPacks(appGroupId: appGroupIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      loadAllPacksChannel.setMessageHandler(nil)
    }
  }
}
