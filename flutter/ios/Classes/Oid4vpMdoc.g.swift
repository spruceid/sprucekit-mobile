// Autogenerated from Pigeon (v26.1.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class Oid4vpMdocPigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "Oid4vpMdocPigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? Oid4vpMdocPigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

func deepEqualsOid4vpMdoc(_ lhs: Any?, _ rhs: Any?) -> Bool {
  let cleanLhs = nilOrValue(lhs) as Any?
  let cleanRhs = nilOrValue(rhs) as Any?
  switch (cleanLhs, cleanRhs) {
  case (nil, nil):
    return true

  case (nil, _), (_, nil):
    return false

  case is (Void, Void):
    return true

  case let (cleanLhsHashable, cleanRhsHashable) as (AnyHashable, AnyHashable):
    return cleanLhsHashable == cleanRhsHashable

  case let (cleanLhsArray, cleanRhsArray) as ([Any?], [Any?]):
    guard cleanLhsArray.count == cleanRhsArray.count else { return false }
    for (index, element) in cleanLhsArray.enumerated() {
      if !deepEqualsOid4vpMdoc(element, cleanRhsArray[index]) {
        return false
      }
    }
    return true

  case let (cleanLhsDictionary, cleanRhsDictionary) as ([AnyHashable: Any?], [AnyHashable: Any?]):
    guard cleanLhsDictionary.count == cleanRhsDictionary.count else { return false }
    for (key, cleanLhsValue) in cleanLhsDictionary {
      guard cleanRhsDictionary.index(forKey: key) != nil else { return false }
      if !deepEqualsOid4vpMdoc(cleanLhsValue, cleanRhsDictionary[key]!) {
        return false
      }
    }
    return true

  default:
    // Any other type shouldn't be able to be used with pigeon. File an issue if you find this to be untrue.
    return false
  }
}

func deepHashOid4vpMdoc(value: Any?, hasher: inout Hasher) {
  if let valueList = value as? [AnyHashable] {
     for item in valueList { deepHashOid4vpMdoc(value: item, hasher: &hasher) }
     return
  }

  if let valueDict = value as? [AnyHashable: AnyHashable] {
    for key in valueDict.keys { 
      hasher.combine(key)
      deepHashOid4vpMdoc(value: valueDict[key]!, hasher: &hasher)
    }
    return
  }

  if let hashableValue = value as? AnyHashable {
    hasher.combine(hashableValue.hashValue)
  }

  return hasher.combine(String(describing: value))
}

    

/// A field requested by the verifier for mDoc presentation
///
/// Generated class from Pigeon that represents data sent in messages.
struct RequestedField180137Data: Hashable {
  /// Field identifier (namespace + element name)
  var id: String
  /// Human-readable display name
  var displayableName: String
  /// Current value of the field (if available)
  var displayableValue: String? = nil
  /// Whether this field can be selectively disclosed
  var selectivelyDisclosable: Bool
  /// Whether the verifier intends to retain this data
  var intentToRetain: Bool
  /// Whether this field is required by the verifier
  var required: Bool
  /// Purpose description for requesting this field
  var purpose: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RequestedField180137Data? {
    let id = pigeonVar_list[0] as! String
    let displayableName = pigeonVar_list[1] as! String
    let displayableValue: String? = nilOrValue(pigeonVar_list[2])
    let selectivelyDisclosable = pigeonVar_list[3] as! Bool
    let intentToRetain = pigeonVar_list[4] as! Bool
    let required = pigeonVar_list[5] as! Bool
    let purpose: String? = nilOrValue(pigeonVar_list[6])

    return RequestedField180137Data(
      id: id,
      displayableName: displayableName,
      displayableValue: displayableValue,
      selectivelyDisclosable: selectivelyDisclosable,
      intentToRetain: intentToRetain,
      required: required,
      purpose: purpose
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      displayableName,
      displayableValue,
      selectivelyDisclosable,
      intentToRetain,
      required,
      purpose,
    ]
  }
  static func == (lhs: RequestedField180137Data, rhs: RequestedField180137Data) -> Bool {
    return deepEqualsOid4vpMdoc(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashOid4vpMdoc(value: toList(), hasher: &hasher)
  }
}

/// A matching credential for the OID4VP request
///
/// Generated class from Pigeon that represents data sent in messages.
struct RequestMatch180137Data: Hashable {
  /// Index in the matches list
  var index: Int64
  /// Credential ID (UUID as string)
  var credentialId: String
  /// Fields requested for this credential
  var requestedFields: [RequestedField180137Data]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RequestMatch180137Data? {
    let index = pigeonVar_list[0] as! Int64
    let credentialId = pigeonVar_list[1] as! String
    let requestedFields = pigeonVar_list[2] as! [RequestedField180137Data]

    return RequestMatch180137Data(
      index: index,
      credentialId: credentialId,
      requestedFields: requestedFields
    )
  }
  func toList() -> [Any?] {
    return [
      index,
      credentialId,
      requestedFields,
    ]
  }
  static func == (lhs: RequestMatch180137Data, rhs: RequestMatch180137Data) -> Bool {
    return deepEqualsOid4vpMdoc(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashOid4vpMdoc(value: toList(), hasher: &hasher)
  }
}

/// Information about the OID4VP request
///
/// Generated class from Pigeon that represents data sent in messages.
struct Oid4vpMdocRequestInfo: Hashable {
  /// Name of the verifier requesting the credential
  var requestedBy: String? = nil
  /// List of matching credentials
  var matches: [RequestMatch180137Data]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> Oid4vpMdocRequestInfo? {
    let requestedBy: String? = nilOrValue(pigeonVar_list[0])
    let matches = pigeonVar_list[1] as! [RequestMatch180137Data]

    return Oid4vpMdocRequestInfo(
      requestedBy: requestedBy,
      matches: matches
    )
  }
  func toList() -> [Any?] {
    return [
      requestedBy,
      matches,
    ]
  }
  static func == (lhs: Oid4vpMdocRequestInfo, rhs: Oid4vpMdocRequestInfo) -> Bool {
    return deepEqualsOid4vpMdoc(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashOid4vpMdoc(value: toList(), hasher: &hasher)
  }
}

/// Result of OID4VP mDoc operations
///
/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol Oid4vpMdocResult {

}

/// Operation succeeded
///
/// Generated class from Pigeon that represents data sent in messages.
struct Oid4vpMdocSuccess: Oid4vpMdocResult {
  var message: String? = nil
  /// Redirect URL (if any) returned after successful presentation
  var redirectUrl: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> Oid4vpMdocSuccess? {
    let message: String? = nilOrValue(pigeonVar_list[0])
    let redirectUrl: String? = nilOrValue(pigeonVar_list[1])

    return Oid4vpMdocSuccess(
      message: message,
      redirectUrl: redirectUrl
    )
  }
  func toList() -> [Any?] {
    return [
      message,
      redirectUrl,
    ]
  }
  static func == (lhs: Oid4vpMdocSuccess, rhs: Oid4vpMdocSuccess) -> Bool {
    return deepEqualsOid4vpMdoc(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashOid4vpMdoc(value: toList(), hasher: &hasher)
  }
}

/// Operation failed with error
///
/// Generated class from Pigeon that represents data sent in messages.
struct Oid4vpMdocError: Oid4vpMdocResult {
  var message: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> Oid4vpMdocError? {
    let message = pigeonVar_list[0] as! String

    return Oid4vpMdocError(
      message: message
    )
  }
  func toList() -> [Any?] {
    return [
      message
    ]
  }
  static func == (lhs: Oid4vpMdocError, rhs: Oid4vpMdocError) -> Bool {
    return deepEqualsOid4vpMdoc(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashOid4vpMdoc(value: toList(), hasher: &hasher)
  }
}

/// Result of processing an authorization request
///
/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol ProcessRequestResult {

}

/// Request processed successfully
///
/// Generated class from Pigeon that represents data sent in messages.
struct ProcessRequestSuccess: ProcessRequestResult {
  var info: Oid4vpMdocRequestInfo


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ProcessRequestSuccess? {
    let info = pigeonVar_list[0] as! Oid4vpMdocRequestInfo

    return ProcessRequestSuccess(
      info: info
    )
  }
  func toList() -> [Any?] {
    return [
      info
    ]
  }
  static func == (lhs: ProcessRequestSuccess, rhs: ProcessRequestSuccess) -> Bool {
    return deepEqualsOid4vpMdoc(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashOid4vpMdoc(value: toList(), hasher: &hasher)
  }
}

/// Request processing failed
///
/// Generated class from Pigeon that represents data sent in messages.
struct ProcessRequestError: ProcessRequestResult {
  var message: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ProcessRequestError? {
    let message = pigeonVar_list[0] as! String

    return ProcessRequestError(
      message: message
    )
  }
  func toList() -> [Any?] {
    return [
      message
    ]
  }
  static func == (lhs: ProcessRequestError, rhs: ProcessRequestError) -> Bool {
    return deepEqualsOid4vpMdoc(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashOid4vpMdoc(value: toList(), hasher: &hasher)
  }
}

private class Oid4vpMdocPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      return RequestedField180137Data.fromList(self.readValue() as! [Any?])
    case 130:
      return RequestMatch180137Data.fromList(self.readValue() as! [Any?])
    case 131:
      return Oid4vpMdocRequestInfo.fromList(self.readValue() as! [Any?])
    case 132:
      return Oid4vpMdocSuccess.fromList(self.readValue() as! [Any?])
    case 133:
      return Oid4vpMdocError.fromList(self.readValue() as! [Any?])
    case 134:
      return ProcessRequestSuccess.fromList(self.readValue() as! [Any?])
    case 135:
      return ProcessRequestError.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class Oid4vpMdocPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? RequestedField180137Data {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? RequestMatch180137Data {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? Oid4vpMdocRequestInfo {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? Oid4vpMdocSuccess {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? Oid4vpMdocError {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? ProcessRequestSuccess {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? ProcessRequestError {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class Oid4vpMdocPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return Oid4vpMdocPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return Oid4vpMdocPigeonCodecWriter(data: data)
  }
}

class Oid4vpMdocPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = Oid4vpMdocPigeonCodec(readerWriter: Oid4vpMdocPigeonCodecReaderWriter())
}


/// OID4VP mDoc presentation API (ISO 18013-7)
///
/// Handles OpenID for Verifiable Presentation with mDoc credentials
/// using the mdoc-openid4vp:// URI scheme
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol Oid4vpMdoc {
  /// Initialize the handler with mDoc credentials from credential packs
  ///
  /// @param credentialPackIds List of credential pack IDs containing mDocs
  /// @return Result indicating success or error
  func initialize(credentialPackIds: [String], completion: @escaping (Result<Oid4vpMdocResult, Error>) -> Void)
  /// Process an authorization request URL
  ///
  /// @param url The authorization request URL (mdoc-openid4vp://...)
  /// @return ProcessRequestResult with matching credentials on success
  func processRequest(url: String, completion: @escaping (Result<ProcessRequestResult, Error>) -> Void)
  /// Submit the presentation response
  ///
  /// @param matchIndex Index of the selected credential match
  /// @param approvedFieldIds List of approved field IDs to share
  /// @return Result with redirect URL on success
  func submitResponse(matchIndex: Int64, approvedFieldIds: [String], completion: @escaping (Result<Oid4vpMdocResult, Error>) -> Void)
  /// Cancel and cleanup the current session
  func cancel() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class Oid4vpMdocSetup {
  static var codec: FlutterStandardMessageCodec { Oid4vpMdocPigeonCodec.shared }
  /// Sets up an instance of `Oid4vpMdoc` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: Oid4vpMdoc?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Initialize the handler with mDoc credentials from credential packs
    ///
    /// @param credentialPackIds List of credential pack IDs containing mDocs
    /// @return Result indicating success or error
    let initializeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.Oid4vpMdoc.initialize\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initializeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let credentialPackIdsArg = args[0] as! [String]
        api.initialize(credentialPackIds: credentialPackIdsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      initializeChannel.setMessageHandler(nil)
    }
    /// Process an authorization request URL
    ///
    /// @param url The authorization request URL (mdoc-openid4vp://...)
    /// @return ProcessRequestResult with matching credentials on success
    let processRequestChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.Oid4vpMdoc.processRequest\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      processRequestChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let urlArg = args[0] as! String
        api.processRequest(url: urlArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      processRequestChannel.setMessageHandler(nil)
    }
    /// Submit the presentation response
    ///
    /// @param matchIndex Index of the selected credential match
    /// @param approvedFieldIds List of approved field IDs to share
    /// @return Result with redirect URL on success
    let submitResponseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.Oid4vpMdoc.submitResponse\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      submitResponseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let matchIndexArg = args[0] as! Int64
        let approvedFieldIdsArg = args[1] as! [String]
        api.submitResponse(matchIndex: matchIndexArg, approvedFieldIds: approvedFieldIdsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      submitResponseChannel.setMessageHandler(nil)
    }
    /// Cancel and cleanup the current session
    let cancelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.sprucekit_mobile.Oid4vpMdoc.cancel\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cancelChannel.setMessageHandler { _, reply in
        do {
          try api.cancel()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cancelChannel.setMessageHandler(nil)
    }
  }
}
